---
title: .NET HTML SDK
author: matthidinger
ms.author: mahiding
ms.date: 10/19/2017
ms.topic: article
---

# .NET HTML SDK

As we described in [Getting Started](../GettingStarted.md) page, an Adaptive Card is a JSON-serialized card object model. This is a .NET library for generating HTML markup, typically from a server.

## NuGet install

[![Nuget install](https://img.shields.io/nuget/vpre/AdaptiveCards.Rendering.Html.svg)](https://www.nuget.org/packages/AdaptiveCards.Rendering.Html)

```console
Install-Package AdaptiveCards.Rendering.Html -IncludePrerelease
```

## Render card

### Instantiate a renderer

The next step is to create an instance of the renderer. 

```csharp
using AdaptiveCards;
using AdaptiveCards.Rendering;
using AdaptiveCards.Rendering.Html;
// ... 

// Create a card renderer
AdaptiveCardRenderer renderer = new AdaptiveCardRenderer();

// For fun, check the schema version this renderer supports
AdaptiveSchemaVersion schemaVersion = renderer.SupportedSchemaVersion; // 1.0
```

### Render a card to HTML

```csharp
// Build a simple card
// In the real world this would probably be provided as JSON
AdaptiveCard card = new AdaptiveCard()
{
    Body = { new AdaptiveTextBlock() { Text = "Hello World" } }
};

try
{
    // Render the card
    RenderedAdaptiveCard renderedCard = renderer.RenderCard(card);

    // Get the output HTML 
    HtmlTag html = renderedCard.Html;

    // (Optional) Check for any renderer warnings
    // This includes things like an unknown element type found in the card
    // Or the card exceeded the maxmimum number of supported actions, etc
    IList<AdaptiveWarning> warnings = rendererdCard.Warnings;
}
catch(AdaptiveException ex)
{
    // Failed rendering
}
```

### Wire up Action events

Any `actions` within the card will render as an HTML `<button>`. Since this is a server-side library it's up to you to wire up client-side event handlers when buttons are pressed. Each `<button>` in the HTML will have attributes that you can use to wire up the proper behavior.

Action Type | CSS class | Additional attributes
---|---|---
`Action.OpenUrl` | `ac-action-openUrl` | `data-ac-url` (the `url` property from the card)
`Action.Submit` | `ac-action-submit` | `data-ac-data` (the `data` property from the card)
`Action.ShowCard` | `ac-action-showCard` | `data-ac-showcardid` (the `id` of the `<div>` containing the inner card)

## Customization

There are 3 ways to customize the adaptive card rendering: 
1. Host Config
2. CSS styling
3. Custom element rendering

### HostConfig 

A [Host Config](../HostConfig.md) is a shared configuration object that all renderers understand. This allows you to define common styles (e.g., font family, font sizes, default spacing) and behaviors (e.g., max number of actions) that will be automatically interpreted by each platform renderer. 

The goal is that the native UI generated by each platform renderer will look very similar with minimal work on your part.

```csharp
// Construct programmatically
renderer.HostConfig = new AdaptiveHostConfig() 
{
    FontFamily = "Comic Sans",
    FontSizes = {
        Small = 15,
        Default = 20,
        Medium = 25,
        Large = 30,
        ExtraLarge= 40
    }
};

// Or parse from JSON
renderer.HostConfig  = AdaptiveHostConfig.FromJson(@"{
    ""fontFamily"": ""Comic Sans"",
    ""fontSizes"": {
        ""small"": 25,
        ""default"": 26,
        ""medium"": 27,
        ""large"": 28,
        ""extraLarge"": 29
    }
}");
```

### CSS styling

While Host Config will get you most of the way there on each platform, it's likely that you will have to do some native styling on each platform. 

HTML makes this easy by adding CSS classes to every element.

| Element | CSS class |
|---|---|
| AdaptiveCard | ac-adaptivecard |
| All Actions | ac-pushButton | 
| Action.OpenUrl  | ac-action-openUrl |
| Action.ShowCard | ac-action-showCard |
| Action.Submit  | ac-action-submit  |
| ActionSet | ac-actionset |
| Column | ac-column |
| ColumnSet | ac-columnset |
| Container | ac-container |
| All Inputs | ac-input |
| Input.ChoiceSet | ac-multichoiceInput  |
| Input.Date | ac-dateInput |
| Input.Number | ac-numberInput |
| Input.Text | ac-textInput |
| Input.Time | ac-timeInput |
| Input.Toggle| - |
| Image  | ac-image |
| ImageSet  | ac-imageset |
| FactSet | ac-factset |
| TextBlock  | ac-textblock |

### Custom Element Rendering

For full control of the renderer you can use the `ElementRenderers` property to **add**, **remove**, or **override** default renderers.

The following example shows how you could define a custom `"type": "Rating"` element and render it.

```csharp
// Register the new type with the JSON parser
AdaptiveTypedElementConverter.RegisterTypedElement<MyCustomRating>();

// Add the new type to the element renderer registry
renderer.ElementRenderers.Set<MyCustomRating>(MyCustomRating.Render);

// Define a custom Rating element type
public class MyCustomRating : AdaptiveElement
{
    public override string Type => "Rating";

    public double Rating { get; set; }

    public AdaptiveTextSize Size { get; set; }

    public AdaptiveTextColor Color { get; set; }

    public static FrameworkElement Render(MyCustomRating rating, AdaptiveRenderContext context)
    {
        var textBlock = new AdaptiveTextBlock
        {
            Size = rating.Size,
            Color = rating.Color
        };
        for (int i = 0; i < rating.Rating; i++)
        {
            textBlock.Text += "\u2605";
        }
        textBlock.Text += $" ({rating.Rating})";
        return context.Render(textBlock);
    }
}
```
